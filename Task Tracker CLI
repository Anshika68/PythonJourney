#!/usr/bin/env python3
"""
Task Tracker CLI (no external deps)

Usage examples:
  python task.py add "Buy milk"
  python task.py update 2 "Buy milk and eggs"
  python task.py delete 3
  python task.py mark 1 in-progress
  python task.py mark 1 done
  python task.py list            # all
  python task.py list done
  python task.py list todo
  python task.py list in-progress

Commands (all positional):
  add <description>
  update <id> <new_description>
  delete <id>
  mark <id> <todo|in-progress|done>
  list [all|todo|in-progress|done]
"""

import argparse
import json
import os
import sys
from datetime import datetime
from typing import List, Dict, Any

DB_FILENAME = "tasks.json"
VALID_STATUSES = ("todo", "in-progress", "done")

def now_iso() -> str:
    return datetime.now().isoformat(timespec="seconds")

def ensure_db_exists(path: str) -> None:
    if not os.path.exists(path):
        with open(path, "w", encoding="utf-8") as f:
            json.dump({"last_id": 0, "tasks": []}, f, indent=2)

def load_db(path: str) -> Dict[str, Any]:
    ensure_db_exists(path)
    try:
        with open(path, "r", encoding="utf-8") as f:
            data = json.load(f)
        # Basic shape validation
        if not isinstance(data, dict) or "tasks" not in data or "last_id" not in data:
            raise ValueError("Corrupt DB schema")
        if not isinstance(data["tasks"], list) or not isinstance(data["last_id"], int):
            raise ValueError("Corrupt DB schema")
        return data
    except json.JSONDecodeError:
        sys.exit("Error: tasks.json is corrupted (invalid JSON). Fix or delete it and try again.")
    except ValueError as e:
        sys.exit(f"Error: {e}")

def save_db(path: str, data: Dict[str, Any]) -> None:
    tmp = path + ".tmp"
    with open(tmp, "w", encoding="utf-8") as f:
        json.dump(data, f, indent=2)
    os.replace(tmp, path)

def next_id(db: Dict[str, Any]) -> int:
    db["last_id"] += 1
    return db["last_id"]

def fmt_task(t: Dict[str, Any]) -> str:
    return f'#{t["id"]:>3}  [{t["status"]:11}]  {t["description"]}  (created {t["created_at"]}, updated {t["updated_at"]})'

def find_task(db: Dict[str, Any], task_id: int) -> Dict[str, Any]:
    for t in db["tasks"]:
        if t["id"] == task_id:
            return t
    return {}

def cmd_add(args: argparse.Namespace) -> None:
    desc = args.description.strip()
    if not desc:
        sys.exit("Error: description cannot be empty.")
    db = load_db(DB_FILENAME)
    tid = next_id(db)
    timestamp = now_iso()
    task = {
        "id": tid,
        "description": desc,
        "status": "todo",
        "created_at": timestamp,
        "updated_at": timestamp
    }
    db["tasks"].append(task)
    save_db(DB_FILENAME, db)
    print(f"Added task #{tid}: {desc}")

def cmd_update(args: argparse.Namespace) -> None:
    try:
        tid = int(args.id)
    except ValueError:
        sys.exit("Error: id must be an integer.")
    new_desc = args.description.strip()
    if not new_desc:
        sys.exit("Error: new description cannot be empty.")
    db = load_db(DB_FILENAME)
    task = find_task(db, tid)
    if not task:
        sys.exit(f"Error: task #{tid} not found.")
    task["description"] = new_desc
    task["updated_at"] = now_iso()
    save_db(DB_FILENAME, db)
    print(f"Updated task #{tid}.")

def cmd_delete(args: argparse.Namespace) -> None:
    try:
        tid = int(args.id)
    except ValueError:
        sys.exit("Error: id must be an integer.")
    db = load_db(DB_FILENAME)
    before = len(db["tasks"])
    db["tasks"] = [t for t in db["tasks"] if t["id"] != tid]
    if len(db["tasks"]) == before:
        sys.exit(f"Error: task #{tid} not found.")
    save_db(DB_FILENAME, db)
    print(f"Deleted task #{tid}.")

def cmd_mark(args: argparse.Namespace) -> None:
    try:
        tid = int(args.id)
    except ValueError:
        sys.exit("Error: id must be an integer.")
    status = args.status.lower()
    if status not in VALID_STATUSES:
        sys.exit("Error: status must be one of: todo, in-progress, done.")
    db = load_db(DB_FILENAME)
    task = find_task(db, tid)
    if not task:
        sys.exit(f"Error: task #{tid} not found.")
    task["status"] = status
    task["updated_at"] = now_iso()
    save_db(DB_FILENAME, db)
    print(f"Marked task #{tid} as {status}.")

def filter_tasks(tasks: List[Dict[str, Any]], which: str) -> List[Dict[str, Any]]:
    if which == "all":
        return tasks
    if which in VALID_STATUSES:
        return [t for t in tasks if t["status"] == which]
    # "not done" alias maps to todo + in-progress
    if which == "not-done":
        return [t for t in tasks if t["status"] in ("todo", "in-progress")]
    # Shouldn't reach here if parser restricts choices
    return tasks

def cmd_list(args: argparse.Namespace) -> None:
    which = args.filter
    db = load_db(DB_FILENAME)
    tasks = filter_tasks(sorted(db["tasks"], key=lambda t: (t["status"], t["id"])), which)
    if not tasks:
        human = which.replace("-", " ")
        print(f"No {human} tasks.")
        return
    print(f"Listing {which.replace('-', ' ')} tasks ({len(tasks)}):")
    for t in tasks:
        print("  " + fmt_task(t))

def build_parser() -> argparse.ArgumentParser:
    p = argparse.ArgumentParser(
        description="Task Tracker CLI â€“ manage tasks in a local JSON file.",
        epilog="Tip: use 'list not-done' to see todo + in-progress."
    )
    sub = p.add_subparsers(dest="command", required=True)

    p_add = sub.add_parser("add", help="Add a new task")
    p_add.add_argument("description", help="Task description")
    p_add.set_defaults(func=cmd_add)

    p_update = sub.add_parser("update", help="Update a task's description")
    p_update.add_argument("id", help="Task id")
    p_update.add_argument("description", help="New description")
    p_update.set_defaults(func=cmd_update)

    p_delete = sub.add_parser("delete", help="Delete a task")
    p_delete.add_argument("id", help="Task id")
    p_delete.set_defaults(func=cmd_delete)

    p_mark = sub.add_parser("mark", help="Mark task status")
    p_mark.add_argument("id", help="Task id")
    p_mark.add_argument("status", choices=list(VALID_STATUSES), help="New status")
    p_mark.set_defaults(func=cmd_mark)

    p_list = sub.add_parser("list", help="List tasks")
    p_list.add_argument("filter", nargs="?", default="all",
                        choices=["all", "todo", "in-progress", "done", "not-done"],
                        help="Filter to apply (default: all)")
    p_list.set_defaults(func=cmd_list)

    return p

def main() -> None:
    parser = build_parser()
    args = parser.parse_args()
    try:
        args.func(args)
    except BrokenPipeError:
        # Handle piping to tools like `head`
        pass

if __name__ == "__main__":
    main()
